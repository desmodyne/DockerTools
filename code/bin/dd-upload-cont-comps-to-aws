#!/usr/bin/env bash

# dd-upload-cont-comps-to-aws
#
# upload Docker container composition images to AWS registry
#
# author  : stefan schablowski
# contact : stefan.schablowski@desmodyne.com
# created : 2018-12-22


# https://docs.aws.amazon.com/AmazonECR/latest/userguide/Registries.html
# NOTE: see also build-cont-comps


echo
echo 'upload Docker container composition images to AWS registry'
echo


# -----------------------------------------------------------------------------
# configure script parameters

# NOTE: I would have thought that these variables are already defined if this
# script is called as a subscript by build; that does not seem to be the case

# path from this script to project root
path_to_proj_root='../..'

# absolute path to this script: http://stackoverflow.com/a/9107028
here="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# absolute, canonical path to project root
# NOTE: realpath fails if path does not exist
path_to_proj_root="$(realpath "${here}/${path_to_proj_root}")"

# absolute path to BashLib library file
path_to_bashlib='/usr/local/lib/dd-bash-lib.sh'

# TODO: shellcheck reports these to be unused
# https://github.com/koalaman/shellcheck/wiki/SC2034

# array with alphabetical list of tools called by this script
# NOTE: too late to test for realpath, already used above
# shellcheck disable=SC2034
req_tools=('aws' 'docker' 'jq' 'yq')

# array with paths to append to PATH
# shellcheck disable=SC2034
ext_paths=()


# -----------------------------------------------------------------------------
# load BashLib

# NOTE: I just assumed BashLib would already be available here if this script
# is called as subscript to build, as build sources it, but this is not true

# NOTE: this only tests if library can be sourced;
# functions are only defined in "$(...)" subshell,
# so a second source for use in here is required
# https://github.com/koalaman/shellcheck/wiki/SC1090
# shellcheck disable=SC1090
if ! output="$(source "${path_to_bashlib}" 2>&1)"
then
    echo "${output}"
    exit 1
fi

# shellcheck disable=SC1090
source "${path_to_bashlib}"


# -----------------------------------------------------------------------------
# run BashLib boilerplate functions

if ! configure_platform              ; then exit 1; fi
if ! extend_path req_tools ext_paths ; then exit 1; fi
if ! get_conf_file_arg "${@}"        ; then exit 1; fi


# -----------------------------------------------------------------------------
# load script configuration

# NOTE: see config file for parameter documentation
# TODO: refactor this out to BashLib function
# TODO: error handling, e.g. check if json / yaml keys are available
# TODO: get this to work with latest yq 2.x

# NOTE: this essentially converts YAML to JSON
# conf_file is defined by proc_cmd_line_args
# https://github.com/koalaman/shellcheck/wiki/SC2154
# shellcheck disable=SC2154
conf="$(yq r -j "${conf_file}")"

aws_def_region="$( jq -r '.aws_def_region'    <<< "${conf}")"
# TODO: use this
# shellcheck disable=SC2034
aws_namespace="$(  jq -r '.aws_namespace'     <<< "${conf}")"
aws_profile="$(    jq -r '.aws_profile'       <<< "${conf}")"
aws_reg_url="$(    jq -r '.aws_reg_url'       <<< "${conf}")"
comp_confs="$(     jq -r '.compositions'      <<< "${conf}")"
cont_namespace="$( jq -r '.cont_namespace'    <<< "${conf}")"
rel_target_root="$(jq -r '.path_to_proj_root' <<< "${conf}")"


# -----------------------------------------------------------------------------
# configure script parameters, cont.

# command shortcut for shorter code
aws="aws --profile ${aws_profile}"

# path to folder that contains configuration file
if ! path_to_conf_folder="$(dirname "${conf_file}")"
then
    exit 1
fi

# absolute, canonical path to TARGET project root
path_to_target_root="$(realpath "${path_to_conf_folder}/${rel_target_root}")"


# -----------------------------------------------------------------------------
# upload container images to AWS registry


if ! pushd "${path_to_target_root}" > /dev/null
then
    echo "Failed to pushd to target project root ${path_to_target_root}"
    exit 1
fi


echo

# http://docs.aws.amazon.com/AmazonECR/latest/userguide/ECR_GetStarted.html
# http://docs.aws.amazon.com/cli/latest/reference/ecr/index.html

# NOTE: this requires local credentials
# usually stored in ~/.aws/credentials
# and created using 'aws configure'
echo -n 'Log into AWS: '
if output="$(${aws} ecr get-login --no-include-email \
                                  --region "${aws_def_region}" 2>&1)"
then
    echo 'OK'
    login_command="${output}"
else
    echo 'ERROR'
    echo "${output}"
    exit 1
fi

echo -n 'Log into AWS Docker repository: '
if output="$(${login_command} 2>&1)"
then
    echo 'OK'

    # TODO: look into output:
    # WARNING! Using --password via the CLI is insecure. Use --password-stdin.
    # Login Succeeded
    if [ -n "${output}" ]
    then
        echo "${output}"
        echo
    fi
else
    echo 'ERROR'
    echo "${output}"
    exit 1
fi

echo -n 'Get existing container image repositories: '
if output="$(${aws} ecr describe-repositories 2>&1)"
then
    echo 'OK'
    repo_json="${output}"
    echo
else
    echo 'ERROR'
    echo "${output}"
    exit 1
fi

if ! existing_repo_uris="$(jq -r '.repositories[].repositoryUri' \
                             <<< "${repo_json}")"
then
    exit 1
fi

if ! comp_names="$(jq -r 'keys[]' <<< "${comp_confs}" | sort)"
then
    exit 1
fi

# TODO: review log output when there are no compositions
# TODO: continue or exit ?
# TODO: review error handling / output / exit code

for comp_name in ${comp_names}
do
    echo "container composition name: ${comp_name}"
    echo

    # NOTE: composition name might contain dashes, so need escaped quotes
    if ! comp_conf="$(jq -r ".\"${comp_name}\"" <<< "${comp_confs}")"
    then
        exit 1
    fi

    if ! comp_conf_path="$(jq -r '.comp_conf_path' <<< "${comp_conf}")"
    then
        exit 1
    fi

    if [ ! -f "${comp_conf_path}" ]
    then
        echo 'Failed to find container composition configuration file at'
        echo "  $(realpath "${comp_conf_path}")"
        exit 1
    fi

    echo -n 'Get container composition image names: '
    if output="$(docker-compose --file "${comp_conf_path}" config \
                   | yq r -j - \
                   | jq -r '.services | to_entries[] | .value.image' 2>&1)"
    then
        echo 'OK'
        image_names="${output}"
        echo
    else
        echo 'ERROR'
        echo "${output}"
        exit 1
    fi

    # TODO: review log output when there are no images
    # TODO: continue or exit ?
    # TODO: review error handling / output / exit code

    for image_name in ${image_names}
    do
        echo "container image name: ${image_name}"
        echo

        # https://stackoverflow.com/a/2172367
        if [[ "${image_name}" != "${cont_namespace}"/* ]]
        then
            echo 'Container image namespace does not match; skip';
            echo
            continue
        fi

        # TODO: aws_namespace ?
        repo_uri="${aws_reg_url}/${image_name}"

        # create container image repo if required
        # NOTE: the usual simple approach fails for e.g. ci-postgres
        # if they are part of another URI, e.g. ci-postgres-sonarqube
        # https://stackoverflow.com/a/229606

        repo_exists=false

        for existing_repo_uri in ${existing_repo_uris}
        do
            if [ "${existing_repo_uri}" = "${repo_uri}" ]
            then
                repo_exists=true
                break
            fi
        done

        if [ "${repo_exists}" = false ]
        then
            echo -n 'Create container image repository: '
            # TODO: aws_namespace ?
            if output="$(${aws} ecr create-repository \
                          --repository-name "${image_name}" 2>&1)"
            then
                echo 'OK'
                echo
            else
                echo 'ERROR'
                echo "${output}"
                exit 1
            fi
        fi


        # TODO: tag image ?
        # tag can also be set in docker-compose.yml file:
        # https://stackoverflow.com/a/37574953
        # https://docs.docker.com/compose/compose-file/#build

        # TODO: introduce image versioning
        repo_tag="${repo_uri}"

        echo -n 'Tag Docker container image with repository info: '
        if output="$(docker tag "${image_name}" "${repo_tag}" 2>&1)"
        then
            echo 'OK'
            echo
        else
            echo 'ERROR'
            echo "${output}"
            exit 1
        fi


        # NOTE: docker push displays its own output
        # TODO: using official url here fails with
        #   Get https://registry.desmodyne.com/v2/: x509: certificate is valid for
        #     *.dkr.ecr.eu-central-1.amazonaws.com, not registry.desmodyne.com
        echo 'Push Docker container image to repository:'
        if ! docker push "${repo_tag}"
        then
            exit 1
        fi

        # NOTE: docker push displays its own output
        echo
        echo 'Remove repository info tag from Docker container:'
        if ! docker rmi "${repo_tag}"
        then
            exit 1
        fi

        echo
        echo "container image ${image_name} upload complete"
        echo
    done

    echo "container composition ${comp_name} upload complete"
    echo
done


if ! popd > /dev/null
then
    echo "Failed to popd from project root ${path_to_target_root}"
    exit
fi


echo 'Docker container composition image upload to AWS registry complete'
echo
